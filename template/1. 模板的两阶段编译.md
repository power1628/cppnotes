## 1. 模板函数系列<1>

### 1.1  模板函数的两阶段编译

模板在编译时需要经过两个步骤：

1. 在模板函数的定义时期，此时模板还未被某个类型实例化（instantiation），此时会经历以下检查：
   1. 语法检查，例如是否少了某些符号
   2. 是否出现了不依赖template parameter的未命名的符号（例如未声明的类型，函数名等）
   3. 不依赖template parameter的static assert 检查
2. 在实例化阶段，模板的代码会被再次针对该类型进行一些检查，是否符合语法规范等。

例如，以下代码：

```cpp
template<typename T>
void foo(T t) {
  funcA(); // 如果funcA()未定义，则在第一阶段检查出错
  funcA(t); // 如果funcA(T)未定义，则在第二阶段检查出错
  static_assert(sizeof(T) > 10, // 第一阶段检查出错
               "int too small");
  static_assert(sizeof(T) > 10, // 如果T的size小于10 
               "T too small"); // 则在第二阶段检查出错
}
```



### 1.2 模板编译时的Link Error

正因为两阶段编译的特性，如果像往常的方式实现模板的声明和定义（声明写在头文件中，定义写在cpp文件中），会导致程序编译时没问题，但是在link时出现 no definition of xxx的报错。

举个例子：

模板函数声明：

```cpp
// myfirst.hpp
#pragma once

// declaration of template
template <typename T>
void printTypeOf (T const&);
```

模板函数定义

```cpp
// myfirst.cpp
#pragma once
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"

// implementation/definition of template
template <typenaem T>
void printTypeOf(T const& x){
  std::cout << typeid(x).name() << "\n";
}
```

使用模板函数

```cpp
// main.cpp
#include "myfirst.hpp"

int main(){
  double x = 3.0;
  printTypeOf(ice); // call function template of double
}
```

这个时候，编译时一切正常，但是在link的时候，会报错`printTypeOf()`函数没有定义。具体原因是`printTypeOf`函数没有被实例化，因为这个函数在实例化double类型的时候，只看到了函数的声明，没有看到函数的定义。

针对这个问题，具体的解决办法很简单，把模板函数的声明和实现都放在头文件中

```cpp
// myfirst2.hpp
#pragma once
#include <iostream>
#include <typeinfo>

// declaration
template <typename T>
void printTypeOf(T const&);

// impl
template<typename T>
void printTypeOf(T const& x) {
  std::cout << typeid(x).name() << "\n";
}
```

#### 1.3 模板函数参数推倒（template argument deduction)

两个概念

```cpp
template <typename T> // T 是template  parameter

T func(T a, T b) // a和b是call parameter
```

为了区分这两个概念，我们这样定义

```cpp
template <typename TmplParam>
void func(CallParam a, CallParam b);
```

TmplParam一般是CallParam的一部分，例如

```cpp
template <typename T>
void func(const T& a, const T& b);
```

当在调用func函数的时候，需要对TemplParam和CallParam类型实例化，如果没有显示指定T的类型，此时涉及到类型的推导和自动转换。

例如

```cpp
int a = 10;
int const b = 20;
func(a, b); // T 被推导为int
```

注意这里b在函数调用时被转换为int类型。

类型推导时类型自动转换的规则：

1. 当CallParam是reference类型时，不会发生人任何类型的自动转换，即使是trivial的类型。当有多个CallParam时，所有CallParam中的TmplParam类型T必须完全一样。
2. 当CallParam被声明为值（value）时，只会发生**基本（trivial）类型**的**衰变转换(decay)**。decay的规则可以参考`std::decay`。注意，不会发生char变int等这种的类型转换。

关于`std::decay<T>`的衰变规则:

 	1. 左值(lvalue)类型衰变为右值(rvalue)类型。`std::decay<T>::type`等价于`std::remove_cv<std::remove_reference<T>::type>::type`。
 	2. 数组类型衰变为指针类型。`std::decay<T>::type`等价于`std::add_pointer<std::remove_extent<std::remove_reference<T>::type>::type>::type`。
 	3. 函数类型衰变为函数指针类型。 `std::decay<T>::type`:等价于 `std::add_pointer<T>:: type`
 	4. 转换将移除T类型的`cv限定符(const 和 volatile)`

```cpp
typedef decay<int>::type         A;                                     // A is int
typedef decay<int &>::type       B;                                     // B is int
typedef decay<int &&>::type      C;                                     // C is int
typedef decay<const int &>::type D;                                     // D is int
typedef decay<int[2]>::type      E;                                     // E is int *
typedef decay<int(int)>::type    F;                                     // F is int(*)(int)
```

几个模板类型自动转换的例子

```cpp
template <typename T>
T max(T a, T b);
...
int i = 10;
int const c = 42;
max(i, c); // OK, T int
max(c, c); // OK, T int 
int& ir = i;
max(i, ir); // OK, T int 
int arr[4];
max(&i, arr); // OK, T int*
max(4, 7.2); // ERROR, T不知道被推倒为int or double
std::string s;
max("hello", s); // ERROR， T不知道应该推倒为char const[6] or std::string
```

除了自动推倒类型外，用户也可以显示的指定T的类型，此时不会发生类型的推倒，因为已经知道对应类型了，例如

```cpp
max<double>(4, 7.2); // OK, 显示制定T为double类型。
```

**对于给定默认参数(default argument)的模板函数，不会发生类型推倒**,例如：

```cpp
template<typename T>
void f(T = "");
...
f(1); // OK, T推倒为int，实际上等价于f<int>(1)
f(); // ERROR，因为不会发生默认参数的推倒，T不知道该推倒为甚么类型，即使给了默认参数为""
```

但是可以对模版参数TmplParam给默认类型，同时指定函数默认参数

```cpp
template<typename T = std::string>
void f(T = "");
...
f(); // OK
```



#### 1.4 模板函数的重载(overload)

C++中有function overloading, function template, function template overloading，当出现一个函数调用的时候，compiler怎么决定改调用哪个函数？对于一个函数调用，compiler决定使用哪个定义好的函数的过程叫做重载解析（overlaod resolution）。过程如下：

* 步骤1: 收集一系列的候选函数，候选集中的函数或者模板函数和被调用的函数有相同的函数名。
* 步骤2: 从候选集中选出所有可行的函数。后选集中的函数有正确的参数数目，并且对于候选集中的函数，有一个顺序关系，顺序按照隐式的参数类型转换确定，其中包括实参类型和形参类型完全匹配的情况。
* 步骤3:从候选集中选择最优可行函数，如果不存在，报错。





* 如果模板函数可以更好的匹配函数调用的参数，则优先选择模板函数，且优先算则最匹配的模板函数。

* 当函数调用显示指定模板函数参数时，则选择模板函数。

* 模板函数重载时注意顺序，调用的函数必须在调用之前声明。

```cpp
#include <cstring>
#include <string>

// maximum of two values of any type
template<typename T>
T max(T a, T b) {
  return b < a ? a : b;
}

// maximum of two pointers
template<typename T>
T* max(T* a, T* b) {
  return *b < *a ? a : b;
}

// maximum of two c string
char const* max(char const* a, char const* b){
  return std::strcmp(b, a) < 0 ? a : b;
}

int main() {
  int a = 7;
  int b = 42;
  auto m1 = ::max(a, b); // 匹配 第一个max - value
	
  std::string s1 = "hello";
  std::string s2 = "world";
  auto m2 = ::max(s1, s2); // 匹配第一个max - value
  
  int* p1 = &b;
  int* b2 = &a;
  auto m3 = ::max(p1, p2); // 匹配第二个max - pointer
  
  char const* x = "hello";
  char const* y = "world";
  auto m4 = ::max(x, y); // 匹配第三个max - c string
}
```

template的重载只会选择最匹配的函数。

```cpp
#include <iostream>

// call by reference
template <typename T>
void funcA(T& a) {
	std::cout << "funcA(const T&) called  " <<  a << std::endl;
}

// call by value
template <typename T>
void funcA(T* a) {
	std::cout << "funcA(T*) called  " <<  a << "\t" << *a << std::endl;
}

// call by reference
template <typename T>
void funcB(T& a) {
	std::cout << "funcB(const T&) called  " <<  a << std::endl;
}

int main(int argc, char** argv) {

	int a = 10;
	int* pa = &a;
	funcA(pa); // 匹配 funcA(T*), call by value
	funcA(a); // 匹配 funcA(T&)，且按照引用传递参数, call by reference

	funcB(pa); // 匹配 funcB(T&), 此时打印出pa的值，也就是a的地址, call by reference
	return 0;
}

/** 
output: 
funcA(T*) called  0x16f9fb6dc	10
funcA(const T&) called  10
funcB(const T&) called  0x16f9fb6dc
*/
```



